#!/usr/bin/env python3
"""Heuristic malware classification based on MEEF IR reports."""

from __future__ import annotations

import argparse
import json
import sys
from collections import defaultdict
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence, Set, Tuple

ClassifierResult = Dict[str, object]


@dataclass
class Rule:
    name: str
    label: str
    summary: str
    required_behaviors: Set[str] = field(default_factory=set)
    any_behaviors: Set[str] = field(default_factory=set)
    required_apis: Set[str] = field(default_factory=set)
    any_apis: Set[str] = field(default_factory=set)
    required_opcodes: Set[str] = field(default_factory=set)
    any_opcodes: Set[str] = field(default_factory=set)
    weight: float = 1.0

    def evaluate(
        self,
        behaviors: Dict[str, int],
        apis: Set[str],
        opcode_counts: Dict[str, int],
    ) -> Optional[Tuple[float, List[str]]]:
        """Return (confidence, evidence) if the rule matches."""
        checks = 0
        satisfied = 0
        evidence: List[str] = []

        if self.required_behaviors:
            checks += len(self.required_behaviors)
            for behavior in self.required_behaviors:
                if behaviors.get(behavior, 0):
                    satisfied += 1
                    evidence.append(f"behavior:{behavior}")
                else:
                    return None

        if self.any_behaviors:
            checks += 1
            matched = sorted(b for b in self.any_behaviors if behaviors.get(b, 0))
            if matched:
                satisfied += 1
                evidence.append("behavior_any:" + ",".join(matched))
            else:
                return None

        if self.required_apis:
            checks += len(self.required_apis)
            for api in self.required_apis:
                if api in apis:
                    satisfied += 1
                    evidence.append(f"api:{api}")
                else:
                    return None

        if self.any_apis:
            checks += 1
            matched = sorted(api for api in self.any_apis if api in apis)
            if matched:
                satisfied += 1
                evidence.append("api_any:" + ",".join(matched))
            else:
                return None

        if self.required_opcodes:
            checks += len(self.required_opcodes)
            for opcode in self.required_opcodes:
                if opcode_counts.get(opcode, 0) > 0:
                    satisfied += 1
                    evidence.append(f"opcode:{opcode}")
                else:
                    return None

        if self.any_opcodes:
            checks += 1
            matched = sorted(op for op in self.any_opcodes if opcode_counts.get(op, 0) > 0)
            if matched:
                satisfied += 1
                evidence.append("opcode_any:" + ",".join(matched))
            else:
                return None

        checks = max(checks, 1)
        confidence = min((satisfied / checks) * self.weight, 1.0)
        return confidence, evidence


class MalwareClassifier:
    def __init__(self) -> None:
        self.rules: Sequence[Rule] = self._build_rules()

    @staticmethod
    def _build_rules() -> Sequence[Rule]:
        ransomware_apis = {
            "CRYPTENCRYPT",
            "CRYPTACQUIRECONTEXTA",
            "CRYPTACQUIRECONTEXTW",
            "CRYPTIMPORTKEY",
            "CRYPTDERIVEKEY",
            "CRYPTGENKEY",
            "CRYPTPROTECTDATA",
            "BCryptEncrypt".upper(),
            "SHFILEOPERATIONA",
            "SHFILEOPERATIONW",
            "DELETEFILEA",
            "DELETEFILEW",
            "MOVEFILEEXA",
            "MOVEFILEEXW",
            "FINDFIRSTFILEA",
            "FINDFIRSTFILEW",
            "FINDNEXTFILEA",
            "FINDNEXTFILEW",
        }

        spyware_apis = {
            "GETASYNCKEYSTATE",
            "GETFOREGROUNDWINDOW",
            "SETWINDOWSHOOKEXA",
            "SETWINDOWSHOOKEXW",
            "SETWINDOWSHOOKA",
            "SETWINDOWSHOOKW",
            "SETWINEVENTHOOK",
            "CALLNEXTHOOKEX",
            "GETWINDOWTEXTA",
            "GETWINDOWTEXTW",
            "GETKEYSTATE",
            "GETMESSAGEA",
            "GETMESSAGEW",
            "GETCLIPBOARDDATA",
        }

        rat_apis = {
            "CREATEREMOTETHREAD",
            "WRITEPROCESSMEMORY",
            "VIRTUALALLOCEX",
            "VIRTUALPROTECTEX",
            "CREATEPROCESSA",
            "CREATEPROCESSW",
            "WINEXEC",
            "SHELLEXECUTEA",
            "SHELLEXECUTEW",
            "OPENPROCESS",
            "WSASOCKETA",
            "WSASOCKETW",
            "CONNECT",
            "SOCKET",
            "RECV",
            "SEND",
        }

        downloader_apis = {
            "URLDOWNLOADTOFILEA",
            "URLDOWNLOADTOFILEW",
            "INTERNETCONNECTA",
            "INTERNETCONNECTW",
            "INTERNETREADFILE",
            "HTTPOPENREQUESTA",
            "HTTPOPENREQUESTW",
            "HTTPSENDREQUESTA",
            "HTTPSENDREQUESTW",
            "WINHTTPOPEN",
            "WINHTTPCONNECT",
            "WINHTTPSENDREQUEST",
            "FTPGETFILEA",
            "FTPGETFILEW",
            "URLMONBINDFILED",
        }

        botnet_apis = {
            "WSASTARTUP",
            "WSASOCKETA",
            "WSASOCKETW",
            "BIND",
            "LISTEN",
            "ACCEPT",
            "CONNECT",
            "SEND",
            "RECV",
            "SELECT",
            "CLOSESOCKET",
            "INET_ADDR",
            "INETNTOA",
            "INTERNETCONNECTA",
            "INTERNETCONNECTW",
        }

        credential_apis = {
            "CREDREADA",
            "CREDREADW",
            "CREDENUMERATEA",
            "CREDENUMERATEW",
            "LOGONUSERA",
            "LOGONUSERW",
            "LSARETRIEVEPRIVATEDATA",
            "LsaRetrievePrivateData".upper(),
            "CRYPTUNPROTECTDATA",
            "WNETADDCONNECTIONA",
            "WNETADDCONNECTIONW",
            "WNETUSECONNECTIONA",
            "WNETUSECONNECTIONW",
        }

        persistence_apis = {
            "CREATESERVICEA",
            "CREATESERVICEW",
            "OPENSERVICEA",
            "OPENSERVICEW",
            "CHANGESERVICECONFIGA",
            "CHANGESERVICECONFIGW",
            "STARTSERVICEA",
            "STARTSERVICEW",
            "REGSETVALUEA",
            "REGSETVALUEW",
            "REGSETVALUEEXA",
            "REGSETVALUEEXW",
            "REGCREATEKEYA",
            "REGCREATEKEYW",
            "REGCREATEKEYEXA",
            "REGCREATEKEYEXW",
            "SCHTASKS",
        }

        wiper_apis = {
            "DELETEFILEA",
            "DELETEFILEW",
            "SHFILEOPERATIONA",
            "SHFILEOPERATIONW",
            "SHEMPTYRECYCLEBINA",
            "SHEMPTYRECYCLEBINW",
            "MOVEFILEEXA",
            "MOVEFILEEXW",
            "SETFILEINFORMATIONBYHANDLE",
            "DEVICEIOCONTROL",
            "NTDELETEFILE",
            "RMDIR",
        }

        rules: List[Rule] = [
            Rule(
                name="ransomware",
                label="Ransomware",
                summary="File and crypto heavy activity consistent with ransom payloads",
                required_behaviors={"uses_fileops", "uses_crypto"},
                any_behaviors={"uses_network", "uses_registry"},
                any_apis=ransomware_apis,
                weight=1.2,
            ),
            Rule(
                name="spyware_info_stealer",
                label="Spyware / Info-Stealer",
                summary="Input monitoring or data theft APIs present",
                any_apis=spyware_apis,
                any_behaviors={"uses_network"},
                weight=1.1,
            ),
            Rule(
                name="remote_access_trojan",
                label="Remote Access Trojan",
                summary="Remote control and code injection indicators detected",
                required_behaviors={"uses_network"},
                any_behaviors={"uses_injection", "uses_memory"},
                any_apis=rat_apis,
                weight=1.2,
            ),
            Rule(
                name="downloader_dropper",
                label="Downloader / Dropper",
                summary="Network retrieval combined with file staging",
                required_behaviors={"uses_network"},
                any_behaviors={"uses_fileops"},
                any_apis=downloader_apis,
                weight=1.0,
            ),
            Rule(
                name="botnet_agent",
                label="Botnet Agent",
                summary="Socket management and command channel patterns",
                required_behaviors={"uses_network"},
                any_behaviors={"uses_persist", "uses_registry"},
                any_apis=botnet_apis,
                weight=1.0,
            ),
            Rule(
                name="credential_stealer",
                label="Credential Stealer",
                summary="Credential harvesting Win32 API usage detected",
                any_apis=credential_apis,
                any_behaviors={"uses_network", "uses_registry"},
                weight=1.1,
            ),
            Rule(
                name="persistence_mechanism",
                label="Persistence / Rootkit",
                summary="Persistence or service manipulation behavior",
                any_apis=persistence_apis,
                any_behaviors={"uses_persist", "uses_registry"},
                weight=0.9,
            ),
            Rule(
                name="destructive_wiper",
                label="Destructive Wiper",
                summary="Bulk file destruction or system wiping patterns",
                required_behaviors={"uses_fileops"},
                any_apis=wiper_apis,
                any_behaviors={"uses_network", "uses_registry"},
                weight=1.0,
            ),
        ]
        return rules

    def classify_ir(self, ir: Dict[str, object]) -> List[ClassifierResult]:
        behaviors = {k: int(v) for k, v in ir.get("behavior", {}).items()}
        apis = {
            entry.get("name", "").upper()
            for entry in ir.get("apis", [])
            if isinstance(entry, dict)
        }
        opcodes = {
            entry.get("name", "").upper(): int(entry.get("count", 0))
            for entry in ir.get("opcodes", [])
            if isinstance(entry, dict)
        }

        matches: List[ClassifierResult] = []
        for rule in self.rules:
            evaluated = rule.evaluate(behaviors, apis, opcodes)
            if evaluated is None:
                continue
            confidence, evidence = evaluated
            matches.append(
                {
                    "category": rule.name,
                    "label": rule.label,
                    "confidence": round(confidence, 3),
                    "summary": rule.summary,
                    "evidence": evidence,
                }
            )

        matches.sort(key=lambda item: item["confidence"], reverse=True)
        return matches


def iter_ir_files(targets: Iterable[Path]) -> Iterable[Path]:
    for target in targets:
        if target.is_file() and target.suffix.lower() == ".json":
            yield target
        elif target.is_dir():
            for path in sorted(target.rglob("*_ir.json")):
                if path.is_file():
                    yield path


def load_ir(path: Path) -> Dict[str, object]:
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def collect_targets(args: argparse.Namespace) -> List[Path]:
    provided: List[Path] = []
    if args.ir:
        provided.append(Path(args.ir))
    if args.dir:
        provided.append(Path(args.dir))
    if not provided:
        provided.append(Path("output/ir_results"))
    return provided


def format_table(results: List[Tuple[Path, List[ClassifierResult]]]) -> str:
    headers = ["IR File", "Primary Label", "Confidence", "Secondary"]
    rows: List[List[str]] = []
    for path, matches in results:
        if matches:
            primary = matches[0]
            secondary = "; ".join(
                f"{item['label']} ({item['confidence']:.2f})" for item in matches[1:3]
            )
            rows.append(
                [
                    path.name,
                    primary["label"],
                    f"{primary['confidence']:.2f}",
                    secondary or "",
                ]
            )
        else:
            rows.append([path.name, "Uncategorized", "0.00", ""])

    col_widths = [max(len(row[idx]) for row in [headers] + rows) for idx in range(len(headers))]
    lines = []
    header_line = " | ".join(headers[idx].ljust(col_widths[idx]) for idx in range(len(headers)))
    divider = "-+-".join("-" * col_widths[idx] for idx in range(len(headers)))
    lines.append(header_line)
    lines.append(divider)
    for row in rows:
        lines.append(
            " | ".join(row[idx].ljust(col_widths[idx]) for idx in range(len(headers)))
        )
    return "\n".join(lines)


def save_json(results: List[Tuple[Path, List[ClassifierResult]]], output_path: Path) -> None:
    payload = []
    for path, matches in results:
        payload.append(
            {
                "ir_file": str(path),
                "classifications": matches,
                "primary": matches[0] if matches else None,
            }
        )
    with output_path.open("w", encoding="utf-8") as handle:
        json.dump(payload, handle, indent=2)


def save_csv(results: List[Tuple[Path, List[ClassifierResult]]], output_path: Path) -> None:
    import csv

    with output_path.open("w", encoding="utf-8", newline="") as handle:
        writer = csv.writer(handle)
        writer.writerow(["ir_file", "primary_label", "confidence", "evidence", "all_labels"])
        for path, matches in results:
            if matches:
                primary = matches[0]
                evidence = ",".join(primary.get("evidence", []))
                labels = ";".join(match["label"] for match in matches)
                writer.writerow(
                    [
                        str(path),
                        primary["label"],
                        f"{primary['confidence']:.3f}",
                        evidence,
                        labels,
                    ]
                )
            else:
                writer.writerow([str(path), "Uncategorized", "0.000", "", ""])


def parse_args(argv: Sequence[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Classify malware IR reports using heuristic rules",
    )
    parser.add_argument(
        "--ir",
        dest="ir",
        help="Single IR JSON file to classify",
    )
    parser.add_argument(
        "--dir",
        dest="dir",
        help="Directory containing IR JSON files (defaults to output/ir_results)",
    )
    parser.add_argument(
        "--output",
        dest="output",
        help="Optional path to save machine-readable output (json or csv)",
    )
    parser.add_argument(
        "--format",
        dest="fmt",
        choices=["table", "json"],
        default="table",
        help="Console display format",
    )
    parser.add_argument(
        "--top",
        dest="top",
        type=int,
        default=3,
        help="Number of matches to retain per sample",
    )
    return parser.parse_args(argv)


def main(argv: Sequence[str]) -> int:
    args = parse_args(argv)
    classifier = MalwareClassifier()
    targets = collect_targets(args)
    ir_files = list(iter_ir_files(targets))

    if not ir_files:
        print("[✗] No IR reports found. Generate IR files before classification.")
        return 1

    results: List[Tuple[Path, List[ClassifierResult]]] = []
    for ir_path in ir_files:
        try:
            ir = load_ir(ir_path)
        except (json.JSONDecodeError, OSError) as exc:
            print(f"[✗] Failed to load {ir_path}: {exc}")
            continue

        matches = classifier.classify_ir(ir)
        if args.top >= 0:
            matches = matches[: args.top]
        results.append((ir_path, matches))

    if args.fmt == "table":
        print(format_table(results))
    else:
        payload = []
        for path, matches in results:
            payload.append(
                {
                    "ir_file": str(path),
                    "classifications": matches,
                    "primary": matches[0] if matches else None,
                }
            )
        print(json.dumps(payload, indent=2))

    if args.output:
        output_path = Path(args.output)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        if output_path.suffix.lower() == ".json":
            save_json(results, output_path)
        elif output_path.suffix.lower() == ".csv":
            save_csv(results, output_path)
        else:
            print(
                f"[!] Unsupported output format for {output_path.name}. Use .json or .csv."
            )

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
